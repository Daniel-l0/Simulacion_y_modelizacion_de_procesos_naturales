[MÚSICA] Hola y bienvenidos de nuevo a la quinta semana de nuestra clase, simulación y modelado de procesos naturales. En el módulo anterior, hemos visto una breve introducción al método reticular de Boltzmann y su relación con el autómata reticular de gas que vimos en la lección anterior. Ahora vamos a entrar en los detalles del método de Boltzmann reticular y a desarrollar el código Python correspondiente. Volvamos al primer paso de la duración de una retícula de Boltzmann, que es un paso de colisión. El paso de colisión lleva a las poblaciones anteriores a la colisión, que colocamos en verde, a las poblaciones posteriores a la colisión, que coloreamos de rojo. Llamamos a las poblaciones y las etiquetamos con una variable que llamamos f. Las poblaciones entrantes son las poblaciones en estado previo a la colisión; las poblaciones verdes, las llamamos f in. En el estado posterior a la colisión, las denominamos población saliente y las denominamos f out. Esas variables, f in y f out, tienen un índice i, que etiqueta las nueve variables que tenemos en cada celda reticular. Así que hay nueve variables para entrar y nueve variables para salir. Como recordatorio, hay nueve porque hay ocho vecinos en dirección focal y diagonal, además de una población en reposo, que no se mueve durante el paso de propagación. En este esquema, le mostramos el nombre de cada variable individual a la izquierda en el estado previo a la colisión, verá que f0 a f3 están en el lado izquierdo, f0 a f2 en el lado izquierdo, f3, f4 y f5 están en el centro y f6, f7 y f8 in están en el lado derecho. Durante la colisión, interactúan y se mueven a la posición opuesta. Por lo tanto, después de la colisión, de f0 a f2 en el lado derecho y f7, de f6 a f8, en el lado izquierdo. Cuando escribas el programa para esto, o cuando escribas código Python, hoy vamos a asignar dos conjuntos de variables. Un conjunto de variables para las poblaciones entrantes y un conjunto de variables para las salientes. Por lo tanto, las poblaciones verdes estarán en su propia matriz y las poblaciones rojas también estarán en su propia matriz. Esto no es necesario, pero facilita un poco el código. Así que esto es lo que vamos a hacer hoy por razones didácticas. En el código Python, que tenemos a la derecha, primero definimos el tamaño del sistema con las variables nx y ny, que son el número de celdas en cada dirección del espacio. Luego asignamos una matriz f en, que es solo una matriz de nueve por nx por ny, y f, de la misma manera. A ambas se les asigna el comando nuMpy zeroes, que las inicializa con un valor cero. Ahora, ¿cómo calculamos las variables macroscópicas en la retícula de Boltzmann? Las calculamos exactamente igual, por supuesto, que en el autómata gaseoso reticular. La densidad es simplemente la suma de todas las poblaciones de un nodo reticular. La densidad, al igual que las poblaciones, depende del espacio y el tiempo. Cada célula tiene su propia densidad. Para calcular la densidad que hay en la celda, se toman las nueve poblaciones y se calcula la suma. Esto le da la densidad de partículas macroscópicas en esta ubicación en el espacio. Si lo hace en el código Python, tendrá que calcular la densidad de densidad en cada punto de la matriz espacial sobre la que hacemos la simulación, lo que significa que empezamos por asignar una matriz para la densidad, de nuevo con el comando ceros, que es una matriz nx por ny. Esta vez perdimos la tercera dimensión porque solo hay una densidad por celda y no nueve variables, como ocurre con las poblaciones. Luego hacemos un bucle en todas las direcciones del espacio, un bucle para la variable ix que repasa todos los valores de nx y para la variable iy que recorre todos los valores en la dirección y. Primero inicializamos la densidad de cada celda para que sea cero, luego recorremos las nueve poblaciones que tenemos en esta celda y las sumamos para volver a almacenarlas en la densidad. De nuestra clase de introducción a Python y a la informática de alto rendimiento, recordará que hay dos maneras de hacer las cosas en Python. O lo hacemos en una notación natural de Python con bucles, como lo hice aquí en el lado izquierdo de la pantalla, o lo hacemos con la sintaxis basada en matrices de NumPy. Puede omitir los bucles de las dimensiones del espacio utilizando una sintaxis basada en matrices que implique estos bucles. Simplemente diciendo que el rol, que no es necesario asignar en este caso, es igual a la suma de las poblaciones. El bucle sobre las direcciones del espacio, en las direcciones x e y, está implícito aquí. Solo tienes que decirle a NumPy en qué dimensión de las poblaciones se debe realizar la suma. Se llevará a cabo en la dimensión que tiene nueve elementos. Es la primera de las tres dimensiones, porque las poblaciones están formadas por una matriz nueve veces nx veces ny. Para ello, indicamos que el eje del parámetro de la suma de comandos es igual a cero, cero para la primera dirección del espacio. En la mayoría de los casos, cuando se hace dinámica de fluidos, nos interesa la presión. Ahora recuerda que los autómatas de gas reticular, en realidad modelan un gas. El método Lattice Boltzmann es el mismo. Se deriva de un autómata gaseoso reticular. Entonces, según el primer principio, es un laberinto para remodelar un gas, no un líquido. Sin embargo, también lo usamos después para modelar un líquido. Recuerda que las ecuaciones [INAUDIBLES] son las mismas, al menos en el primer intento, son las mismas ecuaciones que usarías para remodelar un líquido o un gas. Ahora bien, en un gas, en un gas ideal, la presión es proporcional a la densidad. Si el gas es isotérmico, entonces esta constante de proporcionalidad es igual a la velocidad del sonido dentro de este gas al cuadrado. Así que la presión es igual a la velocidad del sonido al cuadrado y a la densidad. O p es igual a cs fila cuadrada. Como se indica en la primera ecuación, ¿cuál es la velocidad del sonido en nuestro sistema? Existen algunos métodos tradicionales de Boltzmann con los que puedes activar y cambiar la velocidad del sonido como desees. Pero en el modelo D2Q9, la velocidad del sonido es una constante con la que no se puede jugar. La velocidad del sonido al cuadrado es igual a un tercio de este parámetro discreto: delta x al cuadrado sobre delta t al cuadrado. Esta es la primera de la serie de ecuaciones que voy a escribir sin probarlas realmente, porque el propósito de esta lección es desarrollar, prácticamente hablando, junto con usted un primer código reticular de Boltzmann. No tendremos tiempo para desarrollar teóricamente todas las ecuaciones. Simplemente los motivaremos. Si está interesado en obtener más información, encontrará fácilmente más literatura en Internet. ¿Cuáles son las unidades de presión? Estamos acostumbrados a que las unidades NSI tengan una presión como Pascal. Pero si se toma la presión tal y como la definimos allí, se toma la densidad y se multiplica por delta x al cuadrado con delta t al cuadrado. Si delta x son metros y delta t son segundos, obtenemos las unidades de metro cuadrado por segundo cuadrado. Para obtener Pascal, debes multiplicar esto por la densidad del material con el que estás trabajando. Se trata de una propiedad material constante. En un gas, esto podría ser un kilogramo por metro cúbico. O en un líquido, podría ser de 1000 kilogramos por metro cúbico. Multiplica el metro cuadrado o el segundo cuadrado por kilogramo, por metro cúbico, y obtendrás las unidades de Pascal, kilogramo por metro segundo cuadrado. La velocidad es la misma, calculada tal y como la calculamos nosotros en un autómata gaseoso reticular. Para calcular una velocidad, necesitamos introducir un nuevo conjunto de constantes, que son vectores. Las llamamos velocidades reticulares. Las etiquetamos de v0 a v8. Los vectores reticulares son vectores que conectan una de las células de nuestra simulación con una de sus ocho células vecinas o incluso con nueve vecinas, donde la velocidad cero corresponde al resto de la población. Por ejemplo, en el lado izquierdo de la pantalla están las nueve velocidades reticulares que vamos a utilizar para el código que desarrollamos hoy. La primera, v0, apunta a la parte superior derecha de la pantalla. Y tiene los componentes (1,1). v1 tiene los componentes (1,0), v2 (1, -1) y así sucesivamente. Si tiene una celda reticular situada en la posición x, puede encontrar sus ocho vecinas calculando x + delta t multiplicada por una de las velocidades reticulares. La velocidad macroscópica, la velocidad del flujo en una de las celdas, no es más que la suma de todas las poblaciones, al igual que la densidad celular. Pero esta vez se pondera la suma. Se pondera con el valor de las velocidades reticulares. Toman la suma de las nueve poblaciones, las multiplican por la velocidad reticular correspondiente y obtienen la densidad multiplicada por la velocidad. Si solo te interesa la velocidad, divide el resultado por la densidad local y lo calculas como hicimos en la diapositiva anterior. Hagámoslo con el código de Python. Primero, hallamos las velocidades discretas. Las velocidades discretas son una matriz bidimensional porque tenemos nueve velocidades, cada una de las cuales tiene dos componentes. Luego, volvamos a calcular la velocidad primero sin usar la matriz basada en la sintaxis de Python solo con el código tradicional de Python. Así que estamos seguros de entender exactamente lo que está pasando. En primer lugar, asignamos memoria a las velocidades. Es una matriz, una x por una y con dos componentes en cada celda. Por lo tanto, una matriz tridimensional de dos por nx o ny. Tenemos las dos direcciones base [INAUDIBLES], ix e iy. Comience por inicializar los dos componentes de la velocidad de cada celda en cero, luego pase a nueve poblaciones y añada el valor de las poblaciones multiplicado por el componente de la velocidad reticular correspondiente a la velocidad macroscópica. Terminamos al final de este bucle con el valor correcto de la velocidad macroscópica en cada celda. Con la sintaxis NumPy basada en matrices, todo es mucho más fácil de escribir. No necesariamente es mucho más fácil de entender, pero al menos es más corto de escribir. Y como se mencionó en la introducción a Python y a la computación de alto rendimiento, es mucho más rápido, cierto que la forma correcta de formular un código con Python es aquella que se ejecute rápido. En este caso, seguimos recorriendo las nueve poblaciones, pero nos saltamos el bucle temporal. Repasamos las nueve poblaciones y sumamos implícitamente el valor de las poblaciones multiplicado por la velocidad discreta correspondiente, la velocidad reticular, y lo sumamos para obtener la velocidad microscópica. Al final, tenemos que dividir por densidad, porque hay una densidad [INAUDIBLE] multiplicada por la velocidad que no es la velocidad única. En este punto, probablemente te haya confundido por completo, porque usé dos tipos de símbolos que se parecen mucho, pero tienen un significado completamente diferente. En el lado izquierdo de la pantalla tenemos las velocidades reticulares, y en el lado derecho de la pantalla tenemos las poblaciones. Ambas están trazadas mediante flechas. Pero no tienen el mismo significado. Las velocidades reticulares son en realidad vectores, vectores en el sentido matemático del término. Son constantes y no cambian en el tiempo. En el lado derecho, las poblaciones de valores escalares. Simplemente las trazamos como flechas para recordar que, durante el paso de transmisión, se moverán en una dirección hacia un nodo vecino. Pero la flecha no significa que sean vectores, son escalares y su valor viene indicado por el grosor de la flecha. Además, las poblaciones no son constantes. Son las variables que estamos resolviendo en este esquema numérico. Y cambian en el espacio y el tiempo. Este es el final de nuestro módulo sobre variables macroscópicas y el método reticular de Boltzmann. Estén atentos al siguiente módulo. [MÚSICA]