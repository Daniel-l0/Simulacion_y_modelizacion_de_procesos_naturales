[MÚSICA] Hola, bienvenidos de nuevo a la quinta semana de nuestra clase, modelación y simulación de procesos naturales. Como he dicho antes, las condiciones de contorno en dinámica libre son tan importantes como la propia ecuación que estamos resolviendo. No sólo son muy importantes, sino que también son bastante complicadas de aplicar. Y éste es el tema del presente módulo. Como recordatorio, si tomamos un ejemplo de flujo alrededor de un obstáculo, aquí hay diferentes tipos de límites. Un tipo de límite es el límite físico alrededor de la superficie del obstáculo. En este lugar, necesitamos decirle a la simulación que mientras no hay fluido dentro del obstáculo, sólo hay fluido en todas las demás partes. Y hay alguna condición que el fluido debe respetar a lo largo de la superficie del obstáculo para representar las propiedades de la superficie del objeto físico que se coloca allí. También tenemos, además del obstáculo, que es el límite físico, otros tipos de límites que no tienen significado físico. Y que sólo están ahí para implementar una restricción de sistema numérico como en el último en condición de flujo, a la derecha una condición de flujo de salida, y en la parte superior e inferior alguna otra condición. Necesitamos, en resumen, tener una forma numérica, de implementar diferentes tipos de condiciones de contorno. En el flujo de entrada necesitamos una condición de contorno que sea capaz de imponer un determinado perfil de velocidad , que es una forma de decirle al sistema a qué velocidad queremos que fluya el fluido alrededor del obstáculo. En el flujo de salida, necesitamos algo que haga que el flujo de salida se comporte de la forma más discreta posible para que la simulación pueda fingir que el dominio de simulación real es mucho mayor. Y no vemos el efecto de los límites restringidos cortados en el campo de flujo. Lo mismo ocurre también con los límites superior e inferior. Por último, necesitamos una condición de contorno que tenga un significado físico para implementar la física del obstáculo físico. Hay que señalar, que ya tenemos sobre la condición implementada en el código que ha aprendido hasta ahora. Si no hacemos nada, nuestro código es periódico porque es periodicidad lo que implementamos cuando damos el paso de flujo. Como recordatorio, periodicidad significa que todas las porciones de fluido que están saliendo del dominio por la derecha se reinyectarán por la izquierda. Y si están saliendo del dominio por la parte inferior, se reinyectarán por la parte superior. La periodicidad puede ser un uso del reconocimiento de límites. Vamos a utilizarla para el límite inferior y el superior. Pero no va a explotar esta propiedad para el flujo de entrada o el flujo de salida, para los que vamos a hacer algo especial. Comencemos con el obstáculo. La mayoría de los obstáculos, que tenemos en física, tienen una denominada pared de no deslizamiento. iacroscópicamente hablando, esto significa que la velocidad del flujo es cero alrededor del contorno del obstáculo. Si observamos la física desde un punto de vista molecular, significa que la molécula, en promedio, se adhiere de alguna manera a la pared. Significa que, microscópicamente hablando, si observa la pared con un microscopio, verá que tiene una cierta rugosidad superficial. Y debido a esta rugosidad, las moléculas, en promedio, se adherirán a la pared y en promedio, adoptarán una velocidad cero en el área muy pequeña que rodea a cualquiera de las paredes. La condición de no deslizamiento no es la condición adecuada para todas las paredes en física. Hay casos, como por ejemplo, una burbuja de aire en agua, que tienen una condición diferente. Porque si observa una burbuja de aire al microscopio, su superficie es muy lisa incluso a nivel molecular. En este caso, se aplica otra condición. Pero hoy, nos limitaremos a ver cómo implementar la condición más común para obstáculos, paredes sin deslizamiento en lattice Boltzmann. Un esquema numérico para lograrlo es el llamado reconocimiento de límites de rebote. El reconocimiento de límites de rebote es bastante fácil de lograr. Mire lo que hacemos, si tomamos una célula, que está cerrada a un obstáculo. En la imagen de aquí tenemos una célula de celosía, que tiene un obstáculo colocado justo encima. Durante este paso de entrenamiento, tres de la población abandonarán el dominio del fluido y pasarán al fuera de ciclo y necesitarán ser tratadas de una manera especial. Lo que vamos a hacer es lo siguiente. Una población que abandone la celda [INAUDIBLE] la pared, simplemente se reflejará y volverá a la celda de la que salió. Su valor no cambiará durante este paso de entrenamiento. Simplemente tomaremos el mismo valor, lo copiaremos de vuelta a la celda e invertiremos su dirección. Eso es todo. Así es como funciona la condición límite de rebote, tanto para direcciones ortogonales como para direcciones diagonales. Una vez más, observemos la población, que sale de la celda [INAUDIBLE]. Se desplaza hacia la pared. Se invierte. Se refleja y vuelve a la misma celda, estado de precolación verde, sin ninguna modificación del valor de la población. Lo mismo ocurre con las poblaciones que se desplazan a lo largo de las direcciones diagonales. Se mueven hacia la pared durante el flujo, se reflejan a mitad de su movimiento, se invierten y se copian de nuevo a la celda de la que proceden. Tenga cuidado, porque no se trata de un comportamiento intrínseco. Se esperaría que algo que choca contra una pared con un cierto ángulo, se reflejara como en el espejo. Esto no es lo que ocurre aquí. No queremos reflejos. Reflejamos hacia donde vienen, y los copiamos a la misma celda. Esto es lo que hay que hacer para implementar una pared sin deslizamiento en celosía Boltzman. La condición de contorno de rebote es bastante fácil de implementar. Todo lo que hay que hacer es identificar todas las celdas que están cerca de un obstáculo e identificar todas las direcciones de celosía, que unen estos nodos de fluido con los nodos que están dentro del obstáculo. No es difícil, pero implica bastante contabilidad. Hay que identificar para encontrar todas las celdas, que están cerradas en obstáculo, y después pasar por todas las poblaciones y ver cuáles están afectadas y necesitan someterse a un tratamiento especial durante el paso de fluido. No es difícil, pero es un poco incómodo. Afortunadamente, hay una solución fácil para esto. En lugar de modificar realmente este paso de flujo, simplemente transmitimos todas las poblaciones a un nodo sólido. Eso significa que asignamos una memoria para todas las células que están dentro del obstáculo también, y aceptamos que las poblaciones se transmitan desde el fluido a los nodos sólidos. Una vez que están en el nodo sólido, en lugar de hacer más correlaciones dentro del sólido, porque el sólido no es un fluido, simplemente las revertimos dentro del nodo. [INAUDIBLE] ubicación, y que el siguiente paso de flujo, las volvemos a transmitir al lugar de donde vinieron. Veamos cómo funciona esto en detalle. Aquí tenemos dos celdas. Una en la parte inferior izquierda es una celda fluida. La de la parte superior derecha es una celda no fluida, está colocada dentro del obstáculo. Vamos a llamar a esta celda una celda de rebote. Las celdas de rebote, no hacen ningún conjunto de colisión. No hacen un BGK en colisión. En colisión, todo lo que hacen es, tomar toda la población y copiarlos a su ubicación de bolsillo. Durante la transmisión, hacen lo mismo que todas nuestras otras células. Toman la población y los copian a los vecinos. Así que veamos en detalle lo que ocurre si nos centramos en una población, que es la población con índice ocho, que se transmite desde la celda inferior izquierda, la celda fluida a la celda sólida que estamos transmitiendo,. Se copiará sin modificaciones en el nodo de rebote, donde llegará al nodo de rebote en estado verde previo a la correlación. Entonces, durante la correlación, el nodo de rebote no hace nada con todas las poblaciones, incluida la que acaba de recibir, y las copia en la ubicación de repositorio. Así que la colisión toma las poblaciones entrantes, las verdes, las mapea en poblaciones salientes, las rojas que son el valor de la población opuesta y el estado entrante , simplemente revierten todas las poblaciones en direcciones opuestas. Y luego, en el siguiente conjunto de flujo, lo que ocurre de forma natural, es que la población que [INAUDIBLE] como una entró desde la celda inferior izquierda vuelve a la celda de la que salió en la dirección opuesta. La ventaja de hacerlo así es que no necesitamos llevar ningún libro, no necesitamos recordar qué direcciones conectan un fluido con un sólido y cuáles no. Simplemente vamos hasta los nodos de rebote, el que está dentro del sólido y desviamos todas las poblaciones que tenemos allí a colisión sin ninguna distinción, todo es automático. De esta forma, tenemos una forma ordenada y natural de implementar la condición anotada en el método. Esta es la fórmula que describe lo que ocurre en un nodo de rebote en lugar del término de colisión. Durante el término de colisión, los nodos de rebote sólo toman la población saliente en una dirección determinada, que llamamos j, y la copian en la dirección opuesta, que llamamos la dirección con sintaxis i. Así, Fi entrante X por T más 1 es igual a Fj saliente X por T. Y I y J se unen diciendo que I es la dirección opuesta de J, o dicho de otro modo, Vi es igual a menos Vj. Como código Python, este mecanismo funciona de la siguiente manera. Nos centramos primero en todos los nodos que van a implementar un enfoque de rebote. Así que hacemos un bucle sobre las nueve direcciones de la red, tomamos las poblaciones entrantes, en direcciones opuestas y las copiamos de nuevo a las poblaciones del algoritmo en la dirección dada. Enumeramos las velocidades de celosía en este ejemplo, en el algoritmo de celosía de formulación, de tal forma que si recorre las velocidades de celosía verá que lo opuesto a una velocidad dada siempre viene dado por 8 menos la velocidad dada. Por ejemplo la dirección 0 su dirección opuesta es 8, tome 1, su dirección opuesta es 7, su opuesto de es 8 menos i. Tenemos que asegurarnos de que estos mecanismos sólo se aplican a los nodos de rebote y no a los demás nodos. Para ello utilizamos otra matriz a la que llamamos matriz de obstáculos. Es decir, esta matriz, consta de ceros y unos. Cero es para etiquetar todas las posiciones en las que hay fluido, y uno para todas las posiciones que son nodos de rebote. Creamos esta matriz de antemano y la utilizamos como máscara para restringir la operación que puede formularse en esta línea. Dos nodos que tienen el obstáculo mal buscado, que son nodos de obstáculo. NumPy acepta una matriz basada en sintaxis basada en matrices, en máscaras, para restringir el dominio al que se aplica una operación. Con esto termina el tratamiento del obstáculo de las condiciones sobre el obstáculo, y ahora pasamos a la condición de afluencia, que también es muy importante. El propósito de la condición de afluencia, es imponer, de nuevo, velocidad o un perfil de velocidad en todas las celdas que se colocan a lo largo de la frontera izquierda del dominio. En la frontera izquierda, tenemos una especie de problema de la afluencia, porque después de la afluencia, algunas de las poblaciones son desconocidas. Las poblaciones f0, f1, y f2, y el estado entrante, en el estado verde, se desconocen, porque se suponía que debían transmitirse desde las celdas vecinas a la izquierda, que no existen porque están fuera del dominio numérico. Por lo tanto, la condición de contorno necesita encontrar una forma de asignarles un valor. Ya conocemos la velocidad de estas celdas porque la velocidad es el valor que queremos imponer a la condición de contorno. Pero no conocemos la densidad rho ni las tres poblaciones f0, f1, f2. Busquemos la clave de compleción para asignar un valor razonable. Calcular la densidad es bastante fácil, para ello, recordemos las fórmulas para calcular la densidad macroscópica y la velocidad a partir de las poblaciones entrantes. La densidad no es más que la suma de todas las poblaciones. La velocidad en lugar del momento que es la velocidad por la densidad es de nuevo la suma de todas las poblaciones pero esperada por una constante, que proviene de las velocidades de retículo. Ahora despreciaremos los valores de delta x y delta t los pondremos a 1 para pasar a las llamadas unidades de retículo para hacer su ecuación más sencilla. Todos los entrenadores van a punto muerto, no se dis en genio. Dividamos la suma calcular la densidad en tres sumas parciales. La primera suma parcial es rho uno, es la suma de las tres poblaciones en la columna izquierda de f cero más f uno más f dos. De forma similar, rho dos con la suma parcial del medio, es igual a f tres + f4 + f5 y rho 3 es la suma parcial de la derecha, es igual a f6 + f7 + f8. Rho 1 es desconocido, porque es la suma de las tres poblaciones, no lo sabemos, mientras que rho 2 y rho 3 son conocidos. Ahora es fácil calcular la densidad a partir de estas tres sumas parciales. La densidad es simplemente la suma de la fila uno más la fila dos más la fila tres. El momentum, que es la densidad por la velocidad no es mucho más difícil. Centrémonos en el componente x del momentum, hueva por UX. Es igual a la suma de las poblaciones por la componente x de la velocidad de la red correspondiente. Para la fila de la derecha para F6, F7 y F8, esta componente es sólo 1, porque la componente x de las velocidades de la red. Perdón, es menos 1, porque todas apuntan a la izquierda. La componente x de las velocidades del entramado es negativa 1. Para la suma media, para f3, f4 y f5, la componente x de es sólo 0. Así que las despreciamos. Y para f0, f1 y f2, que apuntan todas a la derecha, la componente x de la velocidad es más 1, por lo que la componente x del momento Rho por 2x = rho 1- rho 3. Podemos utilizar estas dos ecuaciones, juntarlas para eliminar la incógnita rho 1, y hallar un valor explícito para la densidad rho. Restando estas dos ecuaciones, obtenemos que rho es igual a rho 2 + 2 rho 3 / 1- ux. En términos puramente aritméticos, encontramos el valor correcto de la densidad en la frontera de entrada. Ahora, también necesitamos encontrar un límite razonable para asignar a las tres poblaciones, f0, f1 y f2. Recuerde que las poblaciones son simplemente iguales al término de equilibrio más una pequeña perturbación. Por lo tanto, como primer intento, simplemente inicialicemos el equilibrio y digamos que f0 entrante es igual al término de equilibrio para la dirección cero. Por ahora, sabemos que el equilibrio de la densidad y la velocidad sólo depende de las variables macroscópicas densidad y velocidad. Así que podemos calcular el término de equilibrio explícitamente y asignarlo a f0. Y lo mismo para f1 y para f2. Pero seamos aún más precisos y corregimos el término de equilibrio por el monitor mediante una perturbación adecuada. Para obtener una buena estimación de esta perturbación, observamos las direcciones opuestas, vemos cuánto se desvían de su equilibrio y copiamos el valor de esta desviación a las poblaciones actuales. Ejemplo, f0 se inicializa primero al equilibrio en la dirección 0, luego vamos a la dirección opuesta f8. Vemos cuánto se desvía del equilibrio, tomamos la diferencia entre f8in menos el término de equilibrio en la dirección 8. Tome esta diferencia y súmela a la dirección f0. En resumen, a la población entrante de 0 se le asigna un valor de equilibrio en la dirección 0, más una diferencia entre la población entrante en la dirección i8 menos el equilibrio en la dirección 8. Haga el mismo procedimiento para f1 y para f2, y ya hemos terminado. Veamos qué aspecto tiene esto en términos de código Python, escrito con sintaxis basada. Para calcular la densidad, necesitamos definir primero los índices de las tres columnas. La columna uno tiene los índices 0, 1, 2. Columna dos, los índices 3, 4, 5. Y columna tres, los índices 6, 7, 8. La densidad en la pared izquierda, en la entrada, es igual es a 1 sobre 1- ux en la misma fila, en la misma columna veces la suma de f3 más f4 más f5, que llamamos rho 2. En Python con la sintaxis no Python utilizamos la palabra clave sum para calcular una suma, e indico con los índices col2 a qué población queremos restringirnos y los indicadores al parámetro de acceso igual a cero. Que la suma debe realizarse sobre las últimas poblaciones sobre el primer índice de la matriz tridimensional [INAUDIBLE]. Lo mismo se hace para calcular la suma sobre la columna tres. Y la fórmula final es la densidad siendo igual a 1 / 1- ux veces rho 2 + 2 x rho 3. Una vez que hemos calculado la densidad, podemos utilizar nuestro esquema de terminación para asignar un valor a las tres poblaciones desconocidas f0, f1 y f2. Son iguales al término equivalente 0, 1 y 2. Más la diferencia entre las poblaciones entrantes 8, 7, 6, que son las opuestas, menos el equilibrio en 8, 7 y 6. Para terminar, busquemos un esquema apropiado] para implementar la condición de salida. Recordemos que la condición de salida debe comportarse como si el dominio no terminara. Queremos implementarla de tal manera que la salida perturbe el sistema lo menos posible. Haremos esto con un truco muy sencillo. En la condición de flujo de salida tenemos, de nuevo, tres poblaciones desconocidas, f6, f7 y f8. En este caso no haremos ningún cálculo complicado, simplemente tomaremos las mismas poblaciones en la celda anterior, que está situada justo a la izquierda dentro del dominio del fluido. Tomamos su valor, lo copiamos a los valores desconocidos en la frontera de salida, y ya está. Al hacer esta simple copia, haremos como si el flujo del fluido ya no variara mucho. Lejos del obstáculo en la condición de frontera exterior. Es como un gradiente cero en las tres poblaciones cercanas a la columna de salida. En términos de Python, lo que eso significa es que tomamos las poblaciones entrantes, a lo largo de la columna 3, que son los índices 6, 7, y 8 en la columna anterior. Tomamos sus valores, los copiamos de nuevo a los índices 6, 7, 8, que es la columna 3 a lo largo de la columna de salida, y hemos terminado. Haciendo este esquema tan sencillo, obtenemos una forma visualmente muy agradable y también físicamente interesante de implementar una condición de flujo de salida. Con esto termina nuestro módulo sobre condiciones de contorno utilizando el método de Boltzmann en celosía . Siga atento al próximo módulo. [MÚSICA]