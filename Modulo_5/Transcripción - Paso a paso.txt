[MÚSICA] Hola y bienvenidos de nuevo a la quinta semana de nuestra clase, Simulación y Modelación de Procesos Naturales. Este módulo tratará sobre el paso de streaming en el método Lattice Boltzmann. Recordemos de nuevo que el streaming lleva a la población del estado de salida de una celda al estado de entrada en las celdas vecinas. Al hacerlo, mapea los valores posteriores a la colisión, que son las flechas f out o rojas, a los valores anteriores a la colisión, que son las flechas f in o verdes. El streaming también lleva a nuestro sistema de un tiempo dado t, al siguiente tiempo t + delta t No hay nada más que decir aquí. Vayamos ahora mismo a un código Python que hace esto. Hay un problema técnico al implementar el paso de flujo, por lo que empezaré de nuevo con un bucle for sobre ambas direcciones x y y del espacio antes de pasar a la nueva sintaxis basada en matrices pi. Esta complicación es que hay que manejar por separado las poblaciones que están en el límite de nuestro dominio, y las que están en flujo fuera del dominio. Tiene que hacer algo con ellas. Lo que eligió hacer en este código, que estamos desarrollando hoy, es tomarlas, sacarlas del dominio y reintroducirlas en el dominio en la dirección opuesta. De este modo, tenemos condiciones de contorno periódicas, todo lo que sale del dominio por la izquierda, entra por la derecha. Si sale por la derecha, entra por la izquierda. Si sale por arriba, entra por abajo, y viceversa. Llamamos a esto condición límite periódica porque el sistema se comporta como si se repitiera periódicamente una cantidad infinita de veces en la dirección en la que es periódico. Si es periódico en la dirección x, es como si tuviera una cantidad infinita de sistemas dispuestos, que son todos iguales, y que están alineados en la dirección x. En la dirección y, significa lo mismo en la dirección y. ¿Entonces cómo manejamos esto en el código? Empezamos con un bucle for con las dos direcciones base de las estancias, y luego para cada dirección, para el área de una de las nueve direcciones, calculamos las coordenadas de la celda vecina. Si las coordenadas de la celda vecina, que son sólo las coordenadas actuales más la velocidad Lattice según la dirección espacial dada. Si estas coordenadas se salen del sistema, lo que significa si su componente x es menor que cero o mayor o igual que nx, o si su coordenada y es menor que cero o mayor o igual que ny, entonces tenemos que ponerla, periódicamente, al otro extremo del sistema. Si sale por el extremo cero, lo volvemos a poner en el extremo nx o ny. Si sale por el extremo nx o ny, lo volvemos a poner en el extremo cero. Implementamos explícitamente la periodicidad de esta forma y entonces el flujo no es más que una copia de las poblaciones salientes a las poblaciones entrantes de las celdas vecinas. Puede hacer lo mismo con la nueva sintaxis rabie de python, aunque es un poco más difícil de entender. Pero más fácil de escribir y mucho más rápido de ejecutar. NumPy ofrece una función que se llama roll que desplazará una matriz periódicamente en una de las direcciones del espacio. Para realizar el paso de flujo, tendremos que llamar a la función roll dos veces, una para desplazarla la cantidad adecuada de celdas en la dirección x y una para desplazarla la cantidad adecuada de celdas en la dirección y. El número de celdas en que se desplaza es 0, 1 ó -1, y viene dado por el valor de la velocidad Lattice que indica la dirección espacial. Así que el código NumPy basado en matrices para el paso de desplazamiento no es más que un bucle sobre nueve direcciones espaciales, una doble llamada a la función de desplazamiento de las poblaciones salientes. Como parámetro, el eje 0 para la dirección x, el eje 1 para la dirección y, y la cantidad de desplazamientos dada por las velocidades Lattice. Y copiamos los resultados de nuevo en las poblaciones entrantes para tenerlas listas para el siguiente paso de colisión. Antes de terminar esta sesión, me gustaría hacer un breve comentario sobre el hecho, sobre la pregunta, si realmente necesitamos asignar tanta memoria. Hemos asignado una matriz enorme que es de tamaño 9 veces nx veces ny. Una para las poblaciones entrantes y otra para las salientes. Eso es mucho. ¿No sería posible simplemente asignar un conjunto de poblaciones y almacenar tanto las poblaciones entrantes como las salientes en el mismo conjunto de variables? La respuesta es sí, es posible. Ni siquiera es difícil de hacer. No lo haremos hoy porque hace que el código sea un poco más complicado. Y prefiero tener un código que sea fácil de leer que realmente eficiente en términos de gestión de memoria. Pero de todos modos, si le interesa este tema, le mostraré cómo proceder si desea almacenar las poblaciones de partículas en una sola matriz. ¿Qué debe tener en cuenta? Cuando realiza el paso de colisión, toma las poblaciones entrantes y calcula localmente la densidad, la velocidad. Calcula el equilibrio, realiza la colisión y almacena el resultado en las poblaciones salientes. En este caso, como todo es local dentro de una única célula, no hay ningún problema. Una vez que ha calculado la colisión, puede almacenar el resultado, las poblaciones salientes, y sobrescribir las poblaciones entrantes, ya no las necesita. Aquí no hay que pensar ni cambiar nada, simplemente se hace, y se almacenan tanto las poblaciones entrantes como las salientes, en la misma matriz. Pero durante la transmisión existe una pequeña complicación. Durante la transmisión, se toman las poblaciones y se copian a las celdas vecinas. Si está trabajando con un solo conjunto de matrices, entonces al transmitir las poblaciones a las celdas vecinas, podría sobrescribir una población que aún necesita y perder información. Sin embargo, si lo piensa detenidamente verá que esto no es un problema en absoluto. Veamos el paso de streaming, y observemos dos poblaciones, una que desde la celda izquierda se propaga a la celda derecha y una que desde la celda derecha se propaga a la celda izquierda. Veamos el movimiento al mismo tiempo. Así que ambas pasan de estados rojos salientes a estados verdes entrantes en la celda vecina. La propiedad interesante es que ocupan una posición en la celda vecina, que acaba de quedar libre porque la población correspondiente, que es de dirección opuesta, también abandonó esta celda. El truco, si quiere trabajar con un solo conjunto de poblaciones, es no hacer pasar partículas de un lado a otro, sino intercambiarlas, hacer un swap. Si toma una población en una celda, identifica su celda vecina. Identifica la población opuesta en esa celda vecina y luego simplemente intercambia los dos valores. En lugar de sobrescribir nada. De este modo, es fácil hacer un modelo Lattice Boltzmann con un solo conjunto de poblaciones en el que guardará tanto las poblaciones entrantes como las salientes. Pero como he dicho, no exploraremos esta propiedad hoy para mantener el código lo más simple posible. Sólo para su información. La misma propiedad también es válida para las direcciones diagonales. Aquí les muestro lo que ocurre si toman la celda inferior izquierda y sacan el f cero de población que, de hecho, es el F8, la población opuesta, que fluye desde la celda inferior izquierda a la celda superior derecha. Y en la celda superior derecha es añadir cero de población, que fluye en la celda inferior izquierda. De nuevo, puede realizar este flujo simplemente intercambiando estos dos valores y evitando sobrescribir cualquier población. Éste es el final de nuestro módulo sobre el paso de flujo en el método de Boltzmann reticular. Siga atento al próximo módulo. [MÚSICA]