[MUSICA] Bienvenidos de nuevo a este curso de la segunda semana sobre Simulación y Modelación de Procesos Naturales. En el segundo módulo introduciremos algunos conceptos de optimización de código. El objetivo de este módulo es hacerles comprender que la forma en que implementan un algoritmo en un ordenador puede influir enormemente en la eficiencia de este modelo. Tomaremos un ejemplo muy sencillo, será un array,que aquí se anota A. Que contiene N enteros y el objetivo de nuestro programa de ordenador sería calcular la suma de todos los enteros contenidos en nuestro array. Así que, como vemos en la parte derecha de la diapositiva, tenemos una representación gráfica por lo que cada número, x0 a xn-1 está almacenado en esta matriz y vamos a recorrer todos los índices y sumarlos a nuestra cantidad S. ¿Entonces cómo lo haría un humano? Primero, leeríamos el primer entero de nuestra matriz y lo añadiríamos a S, luego leeríamos el segundo entero, así x1 y lo añadiríamos a S y así sucesivamente hasta que estuviéramos en el último elemento de nuestra matriz, ¿cómo haríamos eso en un ordenador? Pues existen diferentes formas de hacer exactamente lo mismo en un ordenador. Aquí tenemos tres ejemplos. Hay más para hacerlo con Python. Así que la primera forma en la que implementamos la suma fue tomar la matriz y hacer exactamente lo que habría hecho un ser humano. Así que leemos linealmente los enteros que están almacenados en la matriz y los sumamos a una cantidad global, que se llama S. Esto es normalmente lo que se quiere hacer, porque así es como se almacena una matriz en un ordenador, de forma lineal. Y entonces cuando leemos los enteros estamos entrando en trozos continuos de memoria, lo que suele ser bueno. La segunda forma de hacer aquí muchas otras es recorrer su AR de forma aleatoria. Así que primero, leerá por ejemplo los elementos X O y en lugar de ir a X 1 como hicimos anteriormente saltamos a xn-2. Leemos este xn-2 y lo añadimos a la suma. Entonces desde ahí saltamos a digamos X1 y así sucesivamente, de forma aleatoria en el. Esta suele ser una mala forma de hacerlo porque el ordenador debe saltar muy lejos en su memoria, lo que suele ser ineficiente. Por último, utilizamos una función incorporada en Python que se llama suma que hace exactamente lo que estamos intentando hacer aquí, no sabemos realmente cómo funciona. Pero esperamos que esté construida de una manera lo suficientemente eficiente como para dar buenos resultados. Así que, lo que hicimos es simplemente tomar estas tres implementaciones diferentes, hacer la suma de un Ra grande con un 10 a la potencia de 6 enteros, y medir el tiempo que tardó en hacer la suma. Así que en la primera tabla de esta diapositiva verá que en el extremo derecho se tiene incorporada la función suma que se mide. La segunda por la derecha es aleatoria, y la tercera es lineal. Lo que vemos es que la suma es mucho más rápida que todas las demás aproximaciones, ya que sólo tarda 0,0065 segundos en ejecutarse. Luego tenemos la forma lineal de leer la matriz, y por último la forma aleatoria, que es mucho más lenta. Lo que vemos es que la suma es unas 10 veces más rápida que la forma lineal de leer la matriz, y la forma lineal sigue siendo unas cuatro veces más rápida que la lectura aleatoria de la matriz. Así que vemos que, dependiendo del algoritmo, la forma en que escribamos nuestro algoritmo tendrá un enorme efecto sobre la eficiencia de nuestro programa. La otra cosa que quiero mencionar es que no sólo las instrucciones de un programa son importantes, sino que también lo es el lenguaje del programa. Existe una enorme variedad en los lenguajes de programación que existen. Vamos a llegar a esto un poco más tarde y si cada programa tuviera un lenguaje parámetro como su propio rendimiento digamos. Así que aquí, hice una implementación de estas sumas de array en la forma lineal de leer el array con C++, y también hice la implementación con NumPy, que es una librería para Python 3, utilizada para computación de alto rendimiento que también usaremos en este curso. Así que lo que vemos es que C++ tiene la mejor eficiencia. Es unas 14 veces más rápido que el construido en algunos de Python. Pero lo que también vemos es que NumPy tiene casi el mismo rendimiento que C++. Así que lo que quiero decir con esto es que es importante una vez elegir un lenguaje de programación con el que se sienta seguro, pero no puede renunciar por completo al rendimiento. Así que puede, en ciertos casos, utilizar librerías que le hagan la vida más fácil. En este caso NumPy es una buena elección. Con esto, terminamos el módulo de conceptos de optimización de código. Y en el próximo módulo, hablaremos sobre el concepto de paralelismo. Gracias por su atención. [MÚSICA]