[MÚSICA] Bienvenidos de nuevo a la segunda semana del curso simulación y modelación de procesos naturales. Este es el 12º y último módulo del curso de esta semana. Y hablaremos de NumPy. NumPy es una librería de código abierto o módulo de extensión de Python. Contiene algunas escrituras numéricas muy rápidas y precompiladas que serán muy útiles para este par este curso en general. Tiene como característica básica el soporte de arrays multidimensionales de gran tamaño. Para los que conozcan el lenguaje de programación Matlab es un, maneja estos arrays más o menos de la misma manera. Contiene un montón de retenciones de álgebra lineal, herramientas para hacer transformadas de Fourier y números aleatorios. También permite desintegrar código C/C++ o Fortran. También existe un modelo muy relacionado que es SciPy, que suele venir junto, y que contiene funciones matemáticas aún más avanzadas. Le recomiendo que lo instale si aún no lo ha hecho, y puede encontrar toda la información en la página web de NumPy. Si está utilizando Spyder, que es lo que recomendé al principio del curso, NumPy ya está instalado. Así que no necesita hacer nada. De acuerdo, empecemos con un ejemplo. ¿Qué se hace en este ejemplo? En este ejemplo crearemos dos arrays con números enteros, y luego sumaremos estos arrays. Esta operación se realiza de dos formas. La primera forma es usar las estructuras mínimas que están disponibles en Python, y la otra es usando NumPy. Así que en la cuarta línea vemos una función que está definida, que se llama kist_ver para versión de lista, que tomará como entrada la longitud del array que queramos utilizar. Entonces generaremos dos listas de arrays y luego utilizaremos el módulo de tiempo de Python para medir el tiempo de ejecución de la asignación y suma de las dos áreas. Y al final este programa devolverá el tiempo que se tardó en realizar la asignación y suma de dos arrays. Bien, lo siguiente que definimos es otra función que se llama NumPy_ver o NumPy version, que también toma la longitud del array. Aquí vemos que asignamos x e y como NumPy arrange. Así que no es lo mismo que pero en Python range. Y entonces medimos el tiempo para hacer la operación simple Z = X + Y. Como vemos en este caso, no hay bucle necesario. El NumPy de Python automáticamente asignará y hará la suma y, perdón, asignará Z y hará la suma, elemento a elemento, de X e Y. Finalmente devolverá el tiempo para realizar esta operación. La salida del programa de ejecución es para una longitud de un área de un millón. Y vamos a imprimir el tiempo que se tarda en realizar la asignación y suma de estas dos matrices. Con el menos, se tarda casi un segundo, mientras que con NumPy en alrededor de 0,03 segundos, lo siento. Aproximadamente 30 veces más rápido. Así que vemos que muchas ventajas mediante el uso de NumPy, uno es más rápido. También es mucho más sencillo de usar para estos arrays, no es necesario realizar bucles sobre los índices. Así que es una característica realmente agradable. Ahorrarás mucho código cuando actúes simultáneamente sobre arrays grandes. Tienes otras manipulaciones disponibles para el tipo array de NumPy, que se llaman ndarrays. Así que, por ejemplo, lo que puedes hacer es realizar operaciones Escalar-Matriz. Así, a la izquierda aquí tienes un ejemplo de NumPy, donde importamos el modelo NumPy, y luego creamos la matriz x, que se llena con unos y que tienen aunque mencionaron de los dos doble dos, dos. Así que es una matriz de dos, dos. Luego lo que hacemos es imprimir el resultado de sumar uno más 2,5 veces X. Así que aquí se ve que estamos multiplicando una matriz por un escalar y luego sumando uno. Lo que NumPy hará que determinará automáticamente que debe aplicar el elemento de multiplicación dos veces y el elemento de suma dos veces. Así que el resultado es 3,5, 3,5, 3,5 y 3,5, cuando lo imprimimos. Si estuviéramos haciendo esto en una lista, una forma de hacerlo es asignar dos matrices, una llena de ceros, otra llena de unos, y hacer la misma operación con dos bucles de cuatro. Vemos que esta operación es más variable, requiere mucho más código, aunque el resultado es el mismo al final. También podemos hacer una manipulación matriz-matriz. Así que aquí tenemos un ejemplo en el que asignamos dos, dos matrices. Así que primero asignamos una matriz de longitud cuatro con la función a range, y luego le damos nueva forma. Así que la nueva forma permite cambiar el número de dimensión de una matriz o un array. Luego lo que hacemos es que sumamos estas dos matrices, la sintaxis es exactamente la misma que cuando sumamos dos arrays hace dos diapositivas. Y luego también multiplicaremos estas dos matrices. Así que el resultado para la suma de las dos matrices es simplemente una suma de elementos de ancho. Por supuesto, las dos matrices que sume deben tener un tamaño compatible. No puede sumar una matriz tres por cuatro a una matriz dos por dos, no tendrá sentido. A continuación, también multiplicaremos las dos matrices elemento a elemento con el operador veces. Así, cada elemento se multiplicará por su elemento correspondiente en la otra matriz. Bien, esto tambien se podria hacer con lista asi que este es el ejemplo a la derecha donde asignamos nuestras matrices en las tres primeras lineas y luego tenemos que iterar sobre todos los indices, asi que dos bucles for para sumar las matrices X e Y y almacenarlas en C. Vemos que el resultado de la suma es el mismo que en NuPy, y también podemos hacer lo mismo para la multiplicación. De nuevo, tenemos que iterar explícitamente sobre los índices, lo que no ocurre cuando estamos usando NumPy. Por último, otra gran característica que puede ser muy útil para usted es el paquete de álgebra lineal, que puede hacer toneladas de diferentes funciones de álgebra lineal. Aquí tiene algunos ejemplos de ello. Entonces, primero lo que hacemos en la segunda línea es que definimos una matriz de dos por dos, como lo hicimos en el caso anterior con el rango de remodelación para una matriz, luego definimos un vector que es el rango uno, dos, tres, y lo almacenamos en B. Y entonces podemos imprimir a y b y el producto interior a por b. Así que es el producto vector matriz. Y vemos que el resultado es el esperado. También podemos computar matrices inversas. Así que podemos calcular la matriz inversa de a que es simplemente una función en el modelo linalg n NumPy, así que la llamamos invocando mp.linalg.inv de a, y vemos que si hacemos el producto interior de la inv matriz de a, y a obtenemos la identidad como esperábamos. Por último, también podemos resolver sistemas lineales. Pues imaginemos un sistema lineal que es ax = b y x es la incógnita, para resolver este sistema podemos multiplicar a ambos lados por la matriz inversa de a y resolveremos para x. Pues esto es lo que se hace en la línea 11. Otra forma de hacerlo, que suele ser mucho más rápida, es utilizar la operación solve , que no calcula explícitamente la inversa de la matriz. Simplemente se invoca la función linalg dot solve a,b y se obtiene exactamente el mismo resultado que cuando se multiplica la v por la inversa de a. Así pues, estas son algunas funciones muy básicas del álgebra lineal, pero tiene muchas más como Eigenvalue la composición, qr la competencia, cómputo de determinantes, cómputo de números de condición, y mucho más. Te invito a que indagues un poco más para encontrar todas las características. También te recuerdo que es muy importante que hagas los ejercicios, e incluso que intentes reproducir los códigos que están en las diapositivas, porque así aprenderás a programar. Así, con esto terminamos el módulo sobre NumPy y también la segunda semana del curso sobre simulación y modelización de procesos naturales. Muchas gracias por tu atención. [MÚSICA]