[MUSICA] Bienvenidos de nuevo a este curso de la segunda semana sobre simulación y modelación de procesos naturales. En este 11º módulo hablaremos sobre funciones en Python 3. Entonces, ¿qué es una función? Es relativamente parecida a una función matemática. Es un objeto con el que tomamos uno o muchos parámetros de entrada, hacemos algunos cálculos y damos como salida uno o varios resultados. Hay una diferencia con las funciones matemáticas y es que las funciones en Python también pueden, en algunos casos modificar el parámetro de entrada. Volveremos a eso más adelante. Generalmente, lo que quiere poner en una función son trozos de código que puede querer reutilizar muchas veces. Para no tener que reescribir todas las sentencias todo el tiempo. Es realmente un concepto muy importante en general de la programación. Es realmente un bloque de construcción, un programa es realmente una función. Así que cómo escribimos la sintaxis de una función. Así que dices, a Python a partir de eso, un identificador dado es una función añadiendo la palabra clave def delante de él. Entonces añades el identificador para tu función y entre paréntesis das una lista de parámetros que puede ser tan larga como quieras o también puede estar vacía. Y entonces cierras tus paréntesis y añades el símbolo de columna. Entonces vas a la siguiente línea y usualmente justo debajo de la primera línea, por supuesto indentas como de costumbre. Y puede añadir comentarios entre los códigos triples. Estos comentarios pueden resultar muy útiles, porque pueden servir como documentación para su función. Suelen ser unas pocas palabras que describen lo que hace su función y cómo se hace. Después de comenzar, ponga las sentencias que quiere que su función ejecute y al final puede tener la sentencia return. La sentencia return es opcional y por defecto, todas las funciones devuelven none. No sé si lo recuerda, pero en uno de los módulos anteriores introdujimos este tipo none. Así que si quiere ver si su función terminó de alguna manera, puede simplemente dejar el return en blanco y sabrá si terminó con un none o no. De nuevo, señalo que la indentación es muy importante así que, no la olvide. Otra cosa importante es que puede tener muchos returns en su función. Cuando su código llega al primer retorno, entonces sale y devuelve el resultado que usted quiere que devuelva. Muy bien, veamos un ejemplo para aclararnos un poco. Así que a la izquierda de la diapositiva, definimos una función que comprobará si un número es primo. Así que definimos la función con la palabra clave def, entonces la nombramos se llama, ¿es primo aquí? Y toma como entrada un número, en la primera línea después de la definición tenemos el comando. Perseguimos que la disfunción compruebe si el número es primo. En primer lugar comprobamos si el número es menor o igual que uno si lo es, entonces devolvemos el valor falso. Entonces empezamos a iterar si vamos por E en rango de dos al número de entrada, comprobaremos si una de las i divide al número. Si es el caso, entonces devolverá falso. Si por el contrario, nunca devuelve, simplemente devolverá verdadero, porque ningún número habría dividido a nuestro número. Bien, ¿ahora cómo usamos nuestra función? Primero tal vez, el rango que se utiliza aquí es importante, porque iremos desde 2 hasta un número específico. Si este número es menor o igual a dos, o incluso a tres nunca terminará el bucle porque el rango va desde el primer número que das hasta el último hasta el número el segundo número menos uno. Así que si un número es dos o tres nunca entrará en este bucle. ¿Ahora cómo ejecutamos isPrime? Primero, lo que podemos hacer es usar la función help. La función help leerá los comandos de la línea dos de nuestro código, y los mostrará en pantalla. Así que el resultado de help isPrime, es imprimir su función, el perímetro de la función y muestra también el comando bajo la función. Así que es un comentario interesante para tener una visión rápida de lo que hace la función. Después haremos un bucle sobre la secuencia de números que se genera con el rango, el tipo y para cada I de nuestro rango comprobaremos si es primo o no. Si es primo, imprimiremos el número y diremos que es primo, si no lo es entonces cuando imprimamos el número y diremos que no es primo. Así que los resultados de la derecha son primero, como he dicho antes, la impresión de la ayuda de la función y luego hacemos un bucle de 0 a 12. Y vemos que 0 no es un número primo, uno no lo es, dos es primo, tres es primo y así sucesivamente. En las funciones, tiene sus parámetros, que son variables que puede utilizar. También puede definir nuevas variables o puede utilizar variables definidas previamente. Ahora la pregunta es, ¿cuáles son las variables que puede o no puede utilizar? Así que la regla general es que el ámbito de nuestras variables, donde se puede utilizar, es el bloque donde se ha asignado o declarado, y sólo se puede utilizar después del punto en el que se ha asignado. Así que el primer ejemplo es el ejemplo de una variable global, así que en nuestro programa hemos definido la variable a para que tome el valor Hola y luego hemos llamado a la función foo. ¿Qué hace la función foo? Simplemente imprime a. Así que aquí vemos que a se declara antes que nuestra función, por lo que a tiene el valor ¡Hola! Y se imprime correctamente. Ahora bien, si queremos tener una variable local en una función, vamos al siguiente ejemplo donde definimos la función bar. En la función bar, de nuevo nombramos una variable, que también se llama a, y que tiene el valor Hola. Ahora si ejecutamos nuestro programa en el que primero asignamos, Hola a y luego ejecutamos bar, vemos que la salida es Hola esta vez. Así que significa que hemos creado una nueva variable dentro de la función, que tiene el mismo nombre y anula el valor de la variable a asignada anteriormente. Por último, también podemos tener un error si intentamos utilizar una variable que se asigna después del lugar donde la utilizamos. Así que en el ejemplo de la derecha, de nuevo tenemos el mismo programa principal asignamos un valor a que es Hola y luego ejecutamos la función buzz. ¿Cuál es el propósito de la función zumbido? Debería imprimir a, luego asignar un valor a, que es alto, e imprimir de nuevo. Aquí, rompimos una de las reglas del ámbito de la variable, que es que una variable pertenece al bloque donde ha sido asignada, pero no puede ser usada antes. Aquí, en la línea dos de la función pasada, intentamos utilizar la variable a antes de que haya sido asignada. Así que esto comete un error en la ejecución del código. También les dije como introducción que podemos hacer cosas que no son cosas que podamos hacer habitualmente en las funciones matemáticas normales, que podemos en algunos casos modificar los parámetros de entrada que damos a una función. Veamos qué ocurre con tres tipos diferentes de variables. En primer lugar, un número, cuando el parámetro de una función es un número, aquí tenemos un parámetro a en la función foo. La función foo asignará el valor cuatro a este parámetro de entrada e imprimirá a. La salida de este programa, del programa que se ejecuta ahora, donde asignamos el valor 2 a la variable a, ejecutamos la función foo con el parámetro a e imprimimos a. ¿Y qué pasa? Vemos que la salida es 4 y 2, esto significa que entramos en la función foo ahí cambiamos el valor de a. Se imprimió a 4, pero la variable global a no se modificó por esta operación. Así que no se puede cambiar un número de esta forma. El segundo caso, es cuando el parámetro que introducimos es una lista. Una lista es una variable mutable. Así que lo que hacemos es que creamos una lista, que contiene los números 2, 4, 5 y luego ejecutamos la función bar. ¿Cuál es el propósito de la función barra? Toma a como parámetro modifica su primer índice a menos dos e imprime el parámetro a. Finalmente, una vez que salimos de la función barra, volvemos a imprimir a. Lo que vemos es que ambos resultados de la impresión en la función y al salir de la función son los mismos. Así que la modificación de nuestro lanzamiento en nuestra función también ha modificado el valor global del menos. Por último, si intentamos hacer exactamente lo mismo con una tupla o una cadena, intentamos secuencias inmutables, vemos que tenemos un error. Así que aquí, definimos una cadena, la introducimos como parámetro en la función buzz donde intentamos modificarla y vemos que tenemos un error ocurriendo. Esto ocurre porque las cadenas o tuplas o cualquier lista inmutable prohíben el cambio de uno de estos componentes. Por último, introduciremos brevemente el concepto de módulos en Python. Así que estos se basan en el concepto de programación modular. Estas estructuras básicamente se utilizan para dividir su código en muchas partes simples que luego se pueden combinar fácilmente para producir códigos más complejos. Así que, ¿cómo funciona esto? Para crear un módulo, simplemente guarde funciones, variables, cualquier cosa en un archivo .py. Y cuando quieras usarlo, usas la palabra clave import y el nombre de tu archivo sin la extensión py. Así que como ejemplo, acabamos de guardar la función isPrime que definimos, tres diapositivas antes y la guardamos en un archivo llamado checkPrime.py. Ahora en nuestro intérprete o en un programa simplemente importamos el archivo checkPrime, y entonces podemos usar la función isPrime añadiendo un punto de comprobación, checkPrime y un punto antes de la función isPrime. Aquí, vemos que comprobamos si (8) es un número primo, no lo es así que devolvemos la sentencia false. También podemos para ahorrar algo de texto, algo de tecleo, también podemos dar un alias al módulo que importamos. Aquí, usamos la palabra clave as seguida de los ids que queremos dar a nuestro módulo siguiendo las sentencias import checkPrime. Así que ahora, puede llamar a todas las funciones o variables o cualquier otra cosa que esté en su módulo simplemente tecleando cp.your function, así que aquí estáPrime. Como observación, todas las funciones matemáticas avanzadas que están en Python están en el módulo math. Así que por ejemplo, si quiere hacer una raíz cuadrada o una exponencial debe importar el módulo math. Así que con esto concluimos, el módulo sobre funciones y próximamente haremos una rápida introducción al NumPy. Gracias por su atención. [MÚSICA]