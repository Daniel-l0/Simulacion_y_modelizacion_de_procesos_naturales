[MÚSICA] En este pequeño módulo hablaré un poco de cómo implementar de una forma que sea a la vez eficiente y fácil, y tan segura, la simulación de eventos discretos. El truco que utilizan casi todas las implementaciones serias es considerar una estructura de datos de cola de prioridad que pueda aceptar elemento y función de orden. Y que ordene cada elemento insertado de forma que el primero de la cola sea el más pequeño. Con los sucesos discretos, eso es realmente útil porque como recordará, en la formulación general que le he mostrado, en cada paso nos interesa primero generar elementos, y luego sucesos, y luego resolver el primer suceso en el tiempo. Así que si podemos añadir todos esos sucesos a una cola, y luego resolver la cola por el tiempo del suceso, podemos tener directamente el siguiente elemento en el tiempo, el siguiente suceso en el tiempo, tomando el primero de la cola. Por supuesto, no queremos resolver la cola en cada iteración o tampoco queremos hojear toda la cola para intentar encontrar el primero. Así que si podemos tener una estructura de datos que ordene automáticamente los eventos, podremos acelerar mucho la implementación. Por supuesto, para poder utilizar esta cola de forma eficiente también podemos modificar el significado de una acción. En lugar de tener una función que sólo modifique un estado, modificar el estado actual para reflejar el efecto del evento. Podríamos tener una acción que no sólo sea capaz de modificar el estado sino también de modificar la cola de eventos, por ejemplo, insertando nuevos eventos en la cola o eliminando eventos de la cola que ya no son relevantes. Le mostraré un cierto número de ejemplos después de este pequeño módulo. Pero tenga en cuenta que ahora disponemos de una forma más general de describir acciones, y que podemos considerar que esta cola ordena todos los sucesos y así el primero, la cabeza de la cola, es el siguiente en el tiempo. Por supuesto, esta cola de eventos será un cuello de botella en términos de rendimiento, y tenemos que elegir la estructura de datos adecuada. Hay muchas, la gente utiliza generalmente montones. Yo recomendaré dos estructuras de datos que son realmente, realmente útiles para eventos discretos y la primera es la cola de calendario. Es una estructura de datos que se diseñó para este problema. Así que la cola de calendario no sólo ordena los elementos en el tiempo, sino que lo hace de una forma especialmente inteligente, especialmente si insertas un elemento, por lo que los eventos. Ese es nuestro, la mayoría de las veces más grande, ese es el primero en las colas. Y ese es el caso porque normalmente, cuando resuelves un evento, conlleva nuevos eventos que se añadirán pero que ocurrirán más tarde. Así que la cola de calendario es una excelente opción, y está disponible y hay implementaciones para casi todos los lenguajes. La otra es el montón de emparejamiento, es especialmente adecuado para lenguajes funcionales con una estructura de datos inmutable y el montón de emparejamiento es increíblemente rápido. Realmente sencillo de implementar y de describir. Así que casi siempre es una buena opción si tiene una implementación. Por supuesto, puede hacer la suya propia, y hay muchas otras diferencias. Pero si está empezando a hacer sistemas de eventos discretos, la primera forma, la forma más fácil de empezar es, por supuesto, utilizar cualquier cosa que exista en la biblioteca estándar de su lenguaje. Con esta cola y con este nuevo enfoque y esta nueva definición de acciones, podemos describir el algoritmo de simulación de eventos discretos tal y como le recomiendo que lo utilice. Así que al principio, empezamos estableciendo el tiempo actual igual al comienzo de la simulación. Después generando eventos exógenos, aquí la función exógeno generará todos los eventos y de hecho, podemos considerar que la cola de eventos, la primera cola de eventos es simplemente todos estos eventos exógenos ordenados por tiempo. Podemos inicializar el estado del sistema y después empezamos la evolución. Así que mientras no se cumpla una condición final, ahora la condición final depende del tiempo actual, del estado del sistema en el momento actual y de la cola. Por ejemplo, podemos decidir que terminamos si se alcanza algún estado, o terminamos si la cola está vacía, o terminamos si el tiempo supera un umbral dado. Así que la condición final de nuevo dependerá de lo que se busque exactamente. Y ahora, el algoritmo es realmente sencillo. En cada iteración de este bucle, elegimos el siguiente evento de la cola, que será el primero, por lo que esta operación es realmente rápida. A continuación, podemos obtener el siguiente tiempo y podemos aplicar la siguiente acción nos llevará a este siguiente tiempo. Y esta siguiente acción actualizará tanto el estado del sistema como el estado de la cola añadiendo eventualmente nuevos eventos o eliminando eventos de la cola. Por último, actualizamos el tiempo actual y podemos entonces ejecutar el siguiente. La última consideración sobre la implementación es la paralelización de eventos discretos. En realidad no voy a hablar de ello porque la causalidad de los eventos hace que sea realmente difícil paralelizar. Por ejemplo, supongamos que al principio de la cola tenemos dos eventos diferentes que están separados entre sí por cuatro segundos. Consideremos que dado que existe el siguiente evento que sucederá, podemos procesarlos paralelamente y aplicar las funciones. El problema es que al ejecutar la acción de los primeros eventos podrían producirse nuevos eventos que podrían suceder antes que el segundo evento que estábamos resolviendo en paralelo. Así que no podemos estar seguros de que ningún evento que sucederá antes. Entre medias, lo siento, y dado que no podemos estar seguros de ello, es realmente complicado no producir errores. Generalmente, esto se resuelve mediante tres estrategias. La primera es la optimista. Consideramos que podríamos, pero en caso de que tengamos una violación de causalidad, nos detenemos y retrocedemos hasta el punto en el que aparece esta causalidad. Y entonces serializamos los siguientes eventos, y luego volvemos a intentar de forma optimista paralelizar lo que queda. Si estas causalidades son raras, ese es un buen enfoque. El otro es pesimista o conservador, es que intentamos resolver algún sistema relajado para tratar de predecir si algún suceso podría o no ocurrir en el medio. Y si no pudieran entonces sabemos que podemos paralelizar al menos un poco. Y el último enfoque es el enfoque descuidado, en el que no te preocupas en absoluto y consideras que aunque pudiera aparecer alguna violación de la causalidad que no es tan mala, no podría cambiar el resultado. Por ejemplo, no sé si tienes un gas con muchas colisiones, a veces puedes ignorar eso. Pero no hablaré de ello más profundamente, porque es realmente un tema avanzado y hay mucha literatura interesante al respecto. En el próximo módulo, le presentaré un ejemplo completo sobre cómo modelar una intersección de tráfico. Y le mostraré primero cómo definir el estado, los eventos, y finalmente, le mostraré un ejemplo de ejecución que le ayudará a captar el concepto que le he presentado aquí. [MÚSICA]