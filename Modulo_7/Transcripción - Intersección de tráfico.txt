[MÚSICA] Ahora le presentaré un modelo sencillo sobre una intersección de tráfico. Es todavía, quiero decir un ejemplo de juguete, pero podría refinarse un poco para modelar una intersección de tráfico real. Así que, si entiende el modelo de juguete que presentamos ahora, podría enriquecerlo fácilmente para poder modelar una intersección de tráfico real o incluso el distrito de una ciudad. Entonces, empecemos con esta sencilla situación de aquí. Tenemos una calle principal que va de este a oeste con dos carriles y a la que llegan coches desde dos carriles. Digamos que muchos coches pasan por aquí y una calle secundaria que viene del sur, sólo un carril. Y la mayoría de los coches de hecho que estarán en la calle principal así que queremos mantener el semáforo todo lo rojo que queramos. Todo lo verde, perdón, que queramos. Pero a veces vienen coches de las calles secundarias y entonces tenemos que conmutar el semáforo. Para eso hay una cámara, representada aquí por la imagen de la cámara pequeña, que detecta un coche esperando en la calle secundaria. Y programaremos una conmutación del semáforo para permitir que pasen todos los coches de las calles secundarias. Esta conmutación estará limitada en el tiempo, y entonces el semáforo de la calle secundaria volverá a estar en rojo. Y el semáforo de la calle principal se pondrá en verde. Nos interesa aquí suponer que conocemos el flujo de coches entrantes, los flujos de coches entrantes, en la calle de un solo carril. Cuáles serían los buenos parámetros para minimizar el tiempo de espera de los coches en las calles secundarias y el semáforo en rojo. Y para evitar el bloqueo de las calles principales durante un, más durante un tiempo Importante. El sistema se puede representar muy fácilmente si nos concentramos en los ingredientes necesarios aquí. Entonces, los estados pueden ser por ejemplo el estado del semáforo puede ser representado por una sola variable porque si uno de los semáforos está en rojo sabemos que el otro está en verde. Entonces aquí tenemos una variable f que representa el semáforo en las calles secundarias. Y esta variable puede tener dos estados, rojo o verde. La otra cosa que tenemos que hacer es mantener el número de coches esperando en la segunda calle. Sólo tenemos que mantener un número natural porque para el propósito de cruzar la calle, todos los coches son iguales así que no tenemos que distinguir coches diferentes. Como le dije en el modelo anterior todos los eventos se añadirán a 11Q que se ordenará por el tiempo de ocurrencia del modelo como el primero, el siguiente evento será el siguiente. Y cada evento estará representado tanto por un tiempo, cuando ocurrirá el evento, y una acción podrá cambiar el estado y la cola de eventos para actualizarlo. Aquí el modelo necesitará varios parámetros. Primeros parámetros relacionados con el propio tráfico, que será el horario de llegada de los coches. Cuando llegan los coches a las calles secundarias. Estos parámetros de este tráfico se pueden obtener de dos formas diferentes. En primer lugar podríamos, con sensores cruzados, medir durante una semana o un mes exactamente cuándo llegan los coches, y luego podemos repetir esta semana o este mes con diferentes ajustes para intentar optimizarlos. Pero también podríamos tener un proceso estadístico de [INAUDIBLE] distribución de llegada de coches y podríamos medir el parámetro de la distribución como para poder dibujar como en el contexto de Monte Carlo, dibujar coches que llegan. [SONIDO] Por último tenemos parámetros que están relacionados con los propios semáforos. Y de hecho esos son los parámetros que nos gustaría optimizar o afinar. El primero es la latencia de cambio de los semáforos de verde a rojo, o de rojo a verde. Aquí nos concentramos especialmente en la calle secundaria. Digamos que es la cantidad de tiempo necesaria para que ese semáforo pase de rojo a verde. Y luego, una vez que se ha puesto en verde en la calle secundaria, tenemos que esperar una cantidad de tiempo para que todos los coches, o al menos algunos de ellos, puedan pasar. Para eso tenemos dos números, a es la latencia para cambiar inicialmente el semáforo. Y luego permanecerá en verde durante b, multiplicado por el número de coches que esperan. Tenemos un modelo sencillo en el que la cantidad de tiempo que el semáforo permanecerá en verde es proporcional al número de coches que esperan. Es bastante fácil representarlo con un evento discreto si sólo tenemos en cuenta cuándo llega el coche y el semáforo cambia de color. Para ello tendremos tres eventos, aquí presentados de nuevo en pseudo Python. En primer lugar, cuando el coche llega es el evento CAR t, sería un evento exógeno porque del estado actual del sistema, pero ¿cuál es el extra asociado? En primer lugar, si el semáforo está en rojo, el coche tendría que parar, por lo que podemos aumentar en 1 el número de coches esperando. Si ahora el número de coche que llega es igual a 1, significa que es el primer coche que llega. Eso disparará la cámara que programará el cambio de semáforo. Y para ello, insertamos en la cola un nuevo evento que será de rojo a verde. El semáforo pasa de rojo a verde, y se programará en el tiempo t + a donde a es la latencia y t es el tiempo de llegada del coche. Y si el semáforo estaba en verde, de hecho el coche puede pasar y no tenemos que grabar nada porque saldrá de la intersección de tráfico. Y tenemos otros dos eventos, que están emparejados, para controlar cómo cambia de color el semáforo de la calle secundaria. Primero, tenemos rojo a verde. Y entonces la acción es sencilla, cambiamos el estado del semáforo a verde, e insertamos en la cola un nuevo evento, que es verde a rojo. Y este evento se programará en t, el tiempo actual, más c, el número de coches en espera del tiempo b, que era uno de los dos parámetros que introduje antes. Y podemos decir que el número es 0 porque podemos suponer aquí que todos los coches pasan. Y finalmente, el último evento es de verde a rojo y la acción es simplemente poner el semáforo en rojo. Así que eso es súper fácil de implementar y podemos echar un vistazo al ejemplo de evolución completa. Así que supongamos aquí, que tenemos el parámetro de modelo, 30 segundos para a, por lo que la latencia es de 30 segundos, y la cantidad de tiempo es, digamos verde para CAR es de diez segundos. En el tiempo 0, el número de CAR trabajando es 0. El semáforo está en rojo y tenemos una cola que contiene sólo los eventos porque como no dependen de la evolución del sistema, podemos generarlos de antemano. Así que aquí tenemos cinco coches que llegarán al segundo puesto, 25, 35, 60 y 75. Así que el sistema dará un pico al primer evento, que es un coche a los diez segundos. Así que el tiempo salta a diez, el evento es que llega un coche. Y la acción hará tres cosas aquí. En primer lugar, si aumentamos el número de coches en espera a 1, porque ha llegado un coche, entonces no cambiará el semáforo, seguirá en rojo. Pero se insertará en un tiempo que es igual a 10 + 30 segundos t + a, entonces 40 segundos. Insertaría en la cola un nuevo evento rojo a verde que se insertará en su posición actual. El semáforo programará su cambio. A los 25 segundos, llega un nuevo coche, a los 35 segundos llega otro coche, así que c se va a tres, hay tres coches esperando. A los 40 segundos, finalmente, el semáforo pasa a verde. Eso tendrá dos efectos. En primer lugar, todos los coches esperando se irán, c = 0, y entonces programaremos cuándo el semáforo debe volver a rojo. Y lo hacemos a los 70 segundos, porque son 40 segundos el tiempo actual. Tres coches estaban esperando. Y tenemos un parámetro b de 10, por lo que serían 40 más 3 veces 10. Así que a los 70 segundos, el semáforo debería leerse de nuevo. Así que llega un nuevo coche, y como el semáforo sigue en verde, pasa a los 60 segundos. A los 70 segundos, el semáforo se pone en rojo. 75 segundos, llega un nuevo coche. Y, de nuevo, eso programará primero el cambio de semáforo de rojo a verde y luego la otra transición. Y a los 150 segundos ya no hay ninguna acción en la cola, así que el modelo se detiene porque ha terminado. También podríamos complicar este modelo para tener en cuenta parámetros más realistas como la duración límite para la sincronización entre semáforos en verde. La mejor sincronización entre los dos semáforos, la posibilidad de tener un paso de peatones donde a demanda, el peatón puede pulsar un botón para pedir luz verde para ellos para cruzar. Y así cambiar todos los semáforos a rojo para los coches y así sucesivamente. Y de hecho este sistema crítico tiene realmente una gran ventaja para el tráfico moderno en una ciudad y se utiliza en el contexto comercial y profesional para intentar modelizar el tráfico para una ciudad completa, para una gran ciudad. El problema es que como sólo sabemos lo que ocurre durante los eventos y todo el resto de la evolución está realmente simplificado. No hay forma de visualizar correctamente lo que estaba ocurriendo. Y por esa razón, el resultado generalmente no se presenta de forma visual. Y así pueden tener menos impacto cuando se dirigen a los medios de comunicación o políticos que los modelos eran, se pueden ver todos los coches moviéndose. Pero por otro lado, son realmente rápidos. Puede modelar una ciudad entera, y puede sacar de ella estadísticas realmente precisas y fiables. En el próximo módulo, le presentaremos un ejemplo de investigación real y dejaremos todo el ejemplo de juguete para ver lo que podemos hacer realmente con los eventos discretos y un ejemplo geofísico en el que tenga sentido utilizar eso en lugar de otras soluciones. [MÚSICA]