[MUSICA] Después de describir qué son agente y agente multisistema, ahora diremos algunas palabras sobre cómo implementarlos en un sistema informático. Por supuesto, los Modelos Basados en Agente, los sistemas multiagente son interesantes sólo cuando se implementan en el ordenador porque no hay forma de resolverlos analíticamente, etc. Así que hay varias formas por supuesto de implementarlo, de hecho se puede usar un enfoque completamente nuevo en el lenguaje que se quiera un ejemplo en casi todos los lenguajes. Siempre es posible implementarlos. Pero hay algunos que encajan mejor que otros y piensan que para agente y Objeto-Orientado la definición puede ser realmente buena coincidencia. Porque este tipo de correspondencia de equivalencia entre el concepto de agente basado, modelado de agentes, y el concepto de objeto en objeto orientado. Por ejemplo, tiene una inmodidad de varios tipos de agente. Por ejemplo, vale, si tiene un modelo de hormiga, puede tener una hormiga con diferentes castas, como una hormiga obrera, la hormiga soldado, la reina y así sucesivamente. Así que puede ver la clase en la programación orientada a objetos como una especie de agente. Y entonces cada clase tiene que ser instanciada. Así que puede tener, puede ver que la instancia de esta clase es simplemente el agente. Y tiene una instancia por agente. Si necesita generar un agente durante el modelo, sólo tiene que instanciar la clase. Y un concepto realmente importante de la orientación a objetos, es la encapsulación con miembros privados y públicos. Y aquí es interesante, porque el miembro privado estará haciendo el estado interno del agente. Las memorias, la parte que hace que sea una especie de caja negra desde fuera de la vista. Y el comportamiento será un método público o una colección de métodos públicos. Es cómo el agente reaccionará al estímulo. Así que aquí en [INAUDIBLE] Java, un ejemplo de un agente. Así que, tienes una clase para agentes y aquí tienes una especie de Java porque por supuesto tienes que asignarlos usando un constructor. Pero aquí tienes un ID, así que es realmente importante, es un buen consejo que cada uno de tus agentes tenga un ID diferente. Así que eso te permitirá depurar, rastrear, extraer una única trayectoria. Pero luego tenemos un miembro privado, describimos el estado. Y luego tienes una función de comportamiento. Eso es incluso una percepción, raíz y una acción. Y por supuesto para cada modelo, la percepción. ¿Qué es una percepción? ¿Qué es una acción? Sería diferente, realmente depende de lo que esté intentando modelar. Y dado eso, ahora podemos intentar ver cómo relacionar todas las piezas. Porque de nuevo, si vuelvo atrás, es bastante fácil definir eso para cada agente. Entonces, por supuesto, usted, el conocimiento en la materia le ayudará a sentir lo que hay en el punto y a elegir si el estado será. Pero es bastante fácil hacer esa parte. Y luego tendrá que juntar todos los objetos para hacerlos evolucionar y entonces tenemos dos enfoques básicos. Podemos actualizar el sistema de forma asíncrona o síncrona, como para los autómatas celulares, por ejemplo. Así que les muestro aquí en una especie de Python cómo, la forma general del código, una especie de bucle universal, bucle de actualización universal. Para una actualización sincronizada y una actualización sincrónica. Entonces primero, asincrónica. Asincrónica significa que en cada iteración temporal, tomaré el agente uno tras otro y lo actualizaré. Y una vez que termine de actualizar a todos saltaré a la siguiente iteración. Así que si entramos un poco en detalles. Primero necesitamos inicializar un sistema. Así que aquí tenemos una función inicial que devuelve una lista de agentes. Y luego un entorno inicial. El tiempo es la temporización, el tiempo inicial, y definiremos un tiempo máximo como condición de parada. Podría haber otras condiciones de parada, por supuesto, pero aquí, seguiremos iterando hasta que el tiempo alcance el tiempo máximo. En cada iteración, consideraremos cada agente individualmente. Primero, calcularemos la percepción que tiene el agente que recibimos. Sabiendo el entorno y la lista de todos los demás agentes. Lo llamaremos p, entonces podremos utilizar el agente para calcular este comportamiento y esperaremos una acción. Y finalmente, actualizaremos el entorno utilizando esta acción. Así que el entorno se actualizará, y pasaremos al siguiente agente y calcularemos la percepción para el siguiente agente y así sucesivamente. Cuando hayamos visto a todos los agentes, cuando hayamos iterado sobre todos los agentes, podemos incrementar el tiempo, a menudo puede ser tiempo continuo, pero son posibles otras soluciones. Y si el tiempo sigue siendo menor que el tiempo máximo permitido, volveremos a concentrarnos para ver a todos los agentes. Ese enfoque parece natural, pero tenemos que prestar atención aquí. Porque aquí consideramos siempre los agentes en orden y eso puede introducir un sesgo en el que algunos agentes se vean favorecidos porque su decisión tendrá lugar antes. Así que una de las formas de superar eso es, en lugar de tomar la lista de agentes siempre en el mismo orden, barajamos la lista de agentes en cada iteración. Pero el problema es que algunos fenómenos son realmente síncronos porque están operando al mismo tiempo. Y la, otra forma de implementarlo es usando un síncrono de ese esquema. Así que aquí el código parece más simple, pero no lo es necesariamente. Aquí inicializamos de nuevo el sistema y recibimos una lista de agente y entorno para que el tiempo sea el mismo. Haremos un bucle hasta que alcancemos un pequeño [INAUDIBLE]. La diferencia es que cada paso se realiza en todos los agentes al mismo tiempo. Por ejemplo, aquí calcularemos el mismo paso, pero agente por agente. Aquí, en primer lugar, calcularemos toda la percepción, así que para eso tenemos el entorno, el agente, y recibimos una lista de percepción. Que tiene la misma longitud que la lista de agentes y cada elemento de esta lista es lo que el agente en este índice de la lista percibirá del entorno. Una vez que tenemos todas las percepciones, podemos usar esta función o comportamientos. Que llamará a la función de comportamiento de cada agente sobre esta percepción, y devolverá una lista de acción con la acción que todos los agentes quieren efectuar. Sí, para efectuar un entorno. Así que ahora tenemos que actualizar el entorno. Y el entorno se actualizará utilizando la menor de todas las acciones. Así que si hay conflictos porque dos agentes quieren hacer lo mismo, como ir a la misma posición especial, se obtiene un conflicto que se manejará a este nivel. Así que podemos utilizar nuestra regla para explicar todo este conflicto debe ser manejado. Y luego incrementamos el tiempo de la misma forma que lo hicimos en la actualización síncrona. La parte interesante de la actualización síncrona también, es que es más fácil priorizar. Porque sabes que, por ejemplo, todos los comportamientos, lo que tienes que hacer es, tienes una lista de percepción, una lista de agente. Tienes que tomar ambas listas para ponerlas de lado, cada elemento a un lado. Y luego usar la llamada a la función comportamiento, y luego cada agente en la percepción correspondiente. Y eso lo puedes hacer en paralelo porque no dependerán el uno del otro. Es lo mismo para computar las percepciones. Puedes hacerlo en paralelo, pero si tienes que manejar cada agente uno tras otro, no puedes porque tendrás conflicto y tendrás que terminar sobre ellos. Así que la actualización sincrónica es interesante para eso, pero de nuevo en muchos sistemas en los que la acción es lenta o poco común, no es realista poner que todo ocurra al mismo tiempo. Tienes que elegir dependiendo del problema que tengas. Creo que lo realmente interesante es que tienes que elegir si quieres un enfoque lagrangiano o euleriano. Así que normalmente la gente utiliza un Lagrangiano. Significa que cada agente tiene una localización es consciente, en cierto sentido, de su localización. Y entonces podemos calcular para cada agente ya que conocemos la localización de cada agente, por ejemplo, podemos calcular si los dos agentes están en contacto o si dos agentes están dentro de un radio de comunicación. Lo que cada agente puede ver de su entorno. Una representación típica para eso es una lista de agentes. Donde cada agente tiene una idea en posicionamiento en el a d más o el otro estado variable que podría tener. Y así es bastante común ver eso. El problema es que puede ser realmente lento, porque ingenuamente, si tienes que calcular no sé, topología de interacción web, sabiendo el radio de comunicación de cada agente. Tendrá que considerar todos los pares de agentes para saber si están lo bastante cerca como para comunicarse. Significa algo del orden de n al cuadrado y eso puede ser realmente malo si tiene un número enorme de agentes. Pero podemos tener algo que sea subcuadrático utilizando estructuras de datos especializadas. Así, por ejemplo, el árbol k-d, que dividirá recursivamente el espacio entre todas las direcciones. Usualmente, cuesta O(n log n) construir el árbol kd a partir del punto final. Pero una vez que tiene uno puede en log y modificarlo. Así que log básico en el que es bastante pequeño, y hacer toda la búsqueda rand, como y encontrar todos los agente que están en el son de agente de interés en o de n, la raíz cuadrada de n que le ayuda mucho en sistema grande. Hay otras estructuras interesantes como los árboles r y alguna vez he dedicado tiempo a eso pero si alguna vez sistema realista con muchos agente y necesita ser rápido, tiene que pensar en la que va a utilizar. Una alternativa es utilizar un enfoque euleriano, en ese caso el entorno es una rejilla regular de celdas, un poco como es realmente similar, pero cada celda contiene una lista de agentes Es una lista de agentes como la que le mostré antes. El agente no tiene que conocer su posición exacta, porque puede fingir que está aproximadamente en los mismos puntos cada celda es un punto y todos los agentes. Es como si cada celda fuera una mezcla bien agitada. Y así es rápido calcular la comunicación de interacción antes, porque puede decir, vale primero que cada agente puede comunicarse con cada otro agente en el mismo lugar que están en contacto. Pero para agentes de comunicación más largos puede incluir las células vecinas y así sucesivamente. El movimiento es fácil. Sólo tiene que moverse y luego saltar a la célula de ajuste en la dirección correcta. Y permite un bonito paralelismo. Permite computar la interacción realmente rápido. Para acoplarlo con otro modelo, como autómatas celulares, diferencias finitas. Y por supuesto perderá algo de precisión espacial especial porque en este enfoque, el agente es necesariamente tiene una posición discreta en lugar de tener una continua. Así que el físico puede no ser correcto si tiene una dinámica. Por supuesto, puede combinar ambos enfoques. La variable tiempo es realmente interesante considerarla también. No tiene por qué utilizar el tiempo continuo, porque la mayoría de las veces, el modelo utilizará el tiempo continuo en el que la marca de tiempo aumenta el tiempo en una pequeña cantidad cada iteración temporal. También puede utilizar el tiempo discreto como hemos visto la semana pasada. Y utilizar el ABM, el modelo de base de agente, para actualizar el estado del Sistema de Eventos Discretos. Y aquí el comportamiento es sólo función con fechas y evento. El estado del sistema. Y devolverá el nuevo estado más la colección de evento. Así que si lo mira desde el punto de vista de los Sistemas de Eventos Discretos, cada vez que ocurra un evento encontrará el agente afectado, dará el evento como un percepto al agente. Y el agente reacciona cambiando los estados, y empujando nuevos eventos. Y así puede usar EBM dentro del sistema de eventos discretos sin ningún problema. Así que discutimos sobre alguna preocupación. Sobre cómo implementar módulos basados en agentes. Por supuesto, si quiere entender mejor cómo hacerlo, la mejor manera es intentar implementar un sistema usted mismo. O considerar un marco de módulo agente bis existente y intentar mirar el código fuente para ver cómo lo hicieron. Con esto concluye la parte más general sobre esta conferencia. En el próximo módulo, intentaré tomar dos ejemplos procedentes de la biología y explicarlos adecuadamente y cómo se utilizan los módulos basados en agentes para entenderlos mejor. [MÚSICA]